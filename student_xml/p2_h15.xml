<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="./schema_3302.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<!--the second line in the document associates the schema, so be sure not to change it-->
<DOC>
    <docHead>
        <!--required header includes metadata about the assignment (title, author, version)-->
        <title>A* Pathfinding Algorithm</title>
        <author xml:id="h15">Tammy Huynh</author>
        <version n="1" date="2016-08-01"/>
        <!--note that the date must be YYYY-MM-DD for the document to be valid-->
    </docHead>
    <blog_post>
        <!-- Table of Contents -->
        <list type="roadmap">
            <section_header>Introduction</section_header><pb></pb>
            <section_header>Connect The Dots:  Graphs</section_header><pb></pb>
            <section_header>Bro #1:  Dijkstra’s Algorithm</section_header><pb></pb>
            <section_header>Bro #2:  Best-First Search Algorithm</section_header><pb></pb>
            <section_header>A* Is Born</section_header><pb></pb>
            <section_header>Expanding Horizons</section_header><pb></pb>
            <section_header>TL;DR</section_header>
        </list>
        <background>
            <!-- Introduction -->
            <section_header>Introduction</section_header>
            <question>Okay, so I have this dilemma:  How do I get from A to B as quickly as possible?</question>
            <technical_principle n="1">
                <visual type="drawing" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/map.png">Map</visual>
                Hmmm, maybe we can just guess and check like this?
                <visual type="drawing">
                    guess and checking w/ multiple paths
                    P:  Oh, I guess I’ll try going here. 
                    Hmm, that’s not it. 
                    Here? 
                    No, here…
                    Heeeere?
                    AHA! FINALLY. (He got lucky.)
                </visual>
                That’s nice and dandy and all, but we really shouldn’t depend on luck for these things.
                <visual type="comic" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/vegas.png"></visual>
                And what if we make this map a little more complicated?
                <visual type="drawing">
                    awful map of guessing and checking
                    P:  wut.
                </visual>
                Riiight… We need a more procedural way to do this. That’s where these guys come in handy.
                <visual type="drawing" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/algorithms.png">
                    Algorithm Brothers:  Dijkstra, Best-First, A* (pronounced "A Star")
                </visual>
                They’re what you call algorithms, or a set of well-defined rules in sequence. Before you get to know these algorithms though, you need to understand some basics first. So! That leads us into graphs!
            </technical_principle>
        </background>
        <answer>
            <!-- Graphs -->
            <section_header>Connect The Dots:  Graphs</section_header>
            <technical_principle n="2">
                But before you get to know them, you need to understand some basics first. So! That leads us into graphs!
                <pb></pb>            
                A graph is a collection of nodes or vertices, connected by edges. A square has 4 nodes and 4 edges:
                <visual type="drawing" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/square.png"></visual>
                <analogy>
                    The nodes represent some sort of data, so we don’t need to depict them as points like above. Think of constellations!
                    <visual type="comic" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/constellation.png"></visual>
                </analogy>
                Ah, but how does that relate to our problem? Well, let’s look at our map again.
                <visual type="drawing" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/map_to_graph.png"></visual>
                In this case, the nodes represent our terrain tiles, and the edges represent the connection between adjacent tiles (directly horizontal/vertical or diagonal).
                <visual type="drawing">Depiction of adjacent tiles w/ arrows</visual>
                Got it? Great! We can finally move on to our three algo brothers.
                <visual type="drawing" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/eager_star.png"></visual>
                Shhh, shhh, A*, it’s not your time to shine yet. We need to look at your bros first.
            </technical_principle>
            <pb></pb>
            <!-- Dijkstra's Algorithm -->
            <specific_topic n="1">
                <section_header>Bro #1:  Dijkstra’s Algorithm</section_header>
                Dijkstra’s Algorithm finds the shortest path from a source node to all other nodes. As before, we represent our map as a graph, where our tiles are nodes and the connection between adjacent tiles are edges.
                
                Each of our tiles holds some data. The data that we will look at are the cost from the start A and where they came from <note type="peer" resp="s24">This description feels grammatically confusing. It sounds like you're saying the data on each node is the distance with respect to the starting node, but I am unsure what the 'where they came from' is in reference to.</note>. 
                
                <visual type="image">
                    pic
                </visual>
                But if we haven’t reached the nodes yet, how do we know that information? Ah, that’s a good point. Really, we don’t know, so we will initialize all of the nodes, except A, with an infinite distance and say that they didn’t come from anywhere, or that their parent is null <note type="peer" resp="s24">Using 'parent' and 'null' here without previously defining them. Perhaps this can be established in the 'Graphs' section? Also I think establishing that 'cost' and 'distance' are the same term is necessary, or perhaps only use one term consistently.</note>. Giving them an infinite distance may seem weird, but this ensures that we update it the first time we find a path to it (since the cost we find to it will definitely be less than infinity).
                <visual type="image">
                    A to other tiles: You guys are so far. :c
                    
                    Tile: Guys, where’s mom? :’c
                    Another tile:  WE DON’T HAVE ONE (yet).
                    Tile: T.T
                </visual>
                
                We also have a list, initially empty, that tracks the nodes we visited. To begin the algorithm, we place A on this visited list and then repeat the following steps until we run out of tiles to visit.
                <list type="generic">
                    (1)	Find an unvisited tile closet to our current node.
                    <pb></pb>
                    (2)	Go to that tile and mark it as visited. This means that we have found the shortest path from A to the current node. Thus, if the new node is our goal, we can stop the algorithm. The steps following it are to ensure that we also get the shortest path from A to its neighbors. But really, if we reached the end, we don’t care about them anymore. 
                    <visual type="image">
                        Uninspected tiles:  D’:
                    </visual>
                    But if this wasn’t the goal, go on to (3).
                    <pb></pb>
                    (3)	Look at all of the tiles neighboring this new node. If the cost of the path going from A to the neighbor in which we pass through the current tile is shorter than any previous distance to the node, update it with the shorter path (cost and parent).
                </list>
                <visual type="image">
                    P:  Oh, hey! I found a shortcut! 
                </visual>
                <pb></pb>
                Another way to look at this is that the cost from A to the particular neighbor we’re looking at is the cost from A to the current tile + the cost of the current tile to the particular neighbor.
                <visual type="image">
                    pic of added distance
                </visual>
                
                Eventually, we will run out of nodes to inspect and end up with a list of the shortest paths from A to all other nodes.
                
                If we find that the cost from A to a particular node is still infinity, then there is no path to between the two.
                
                <visual type="image">
                    Person at blocked off tile:  If only they knew how to climb walls :’(
                </visual>
                Alright, that may have been a little confusing, so let’s go through a full run-through on a small map.
                <visual type="image">
                    Dijkstra's run-through
                </visual>
                <!-- NEED TO FIX THIS.-->
                And that’s it! If you got all of that, you’ve almost got A* down too, but before we go there, let’s look at Bro #2 to really get the full picture.
                <visual type="image" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/upset_star.png"></visual>
            </specific_topic>
            <pb></pb>
            <!-- Best-First Search Algorithm -->
            <specific_topic n="2">
                    <section_header>Bro #2:  Best-First Search Algorithm</section_header>
                    
                    Unlike Dijkstra’s, Best-First Search uses a heuristic to estimate the shortest path between A and B (recall that Dijkstra’s is from A to any other node). A heuristic is a method where we use an educated “guess” to lead us to the solution.
                    
                    <visual type="image">
                        P: But I thought you said my guessing strategy wasn’t good? Pointing to previous image
                    </visual>
                    
                    What you did before was ransdomly guessing. This is using an educated guess as a guide. 
                    <analogy>Think of a detective who’s searching for a criminal. If she doesn’t have anything to go off, she has to visit every district. But if she gets a good clue that the criminal is around District A, she can direct her investigation there. We can think of the heuristic as a tipoff.</analogy>
                    
                    <visual type="image">
                        image of searching at District A
                    </visual>
                    
                    In Best-First, the heuristic is the estimated cost from the current node to the end node B. 
                    <question_relevant_topic n="1">
                        There are various ways to get the heuristic value, but the most common way is with the Manhattan method. This method counts the distance traversed only horizontally and vertically to get to the end, ignoring any diagonal movement and obstacles.
                    
                        [Manhattan distance formula]
                        
                        This distance, also called the taxicab distance, is named after the New York borough Manhattan, which is known for its grid-like streets.
                        
                        <visual type="comic">
                            Manhattan grid map w/ taxis
                            
                            P: Why don’t you just do this? (diagonal)
                            TD: I mean if you want me to drive through buildings…
                            P: Oh. No, no, I’m good.
                        </visual>
                    </question_relevant_topic>
                    Best-First trades accuracy for speed. If we have no obstacles, BFS works well.
                    
                    <visual type="image">
                        BF:  I win!
                        D:  PUNK!
                    </visual>
                    
                    But if we end up introducing a wall, the path will resemble this:
                    
                    <visual type="image">bad Best-First</visual>
                    
                    That’s because Best-First only thinks of the distance to the end and fails to update the path prior to the wall. It disregards early nodes if they aren’t close to the end even if they turn out to be more optimal later.
                    
                    <visual type="image">
                        BF:  Ok, so the shortest route is this way! AHRG A WALL. Well, I’ll just keep this path and combine it with the shortest path starting here… Not gonna waste time looking at those nodes I kicked out earlier. (Don’t tell Dijkstra.)
                        D:  smh
                        
                        Nodes: We had potential! D’:
                    </visual>
                    
                    We won’t dive deep into this algorithm since A* is more similar in implementation to Dijkstra’s.
                    
                    <visual type="image">BF: Well, ok, it was nice to meet you. ;w;</visual>
            </specific_topic>
            <pb></pb>
            <!-- A* Is Born -->
            <explanation n="1">
                <section_header>A* Is Born</section_header>
                <visual type="drawing">A*: Hi. c:</visual>
                A* is a fusion of Dijkstra’s and Best-First.
                <visual type="comic" url="https://raw.githubusercontent.com/huynhta1/awd_p2_images/master/fusion.png">DBZ fusion dance</visual>
                It takes into account both the cost from the start to the current node and the cost from the current node to the end.
                <pb></pb>
                F = G + H
                <pb></pb>
                Where <pb></pb>
                G = cost from the start to the current node <pb></pb>
                H = estimated cost from the current node to the end
                <pb></pb>
                Remember, we say H, the heuristic value, is an estimate because there are many things that it doesn’t take into account, like obstacles.
                <!-- NEED TO FINISH THIS.-->
            </explanation>
            <important_idea n="1">
                <pb></pb>
                <!-- Expanding Horizons -->
                <section_header>Expanding Horizons</section_header>
                Talk about adjusting the algorithms to fit different cases here.
            </important_idea>
            <conclusion>
                <pb></pb>
                <!-- TL;DR -->
                <section_header>TL;DR</section_header>
                Alright, alright. I’ll give you the meat and beans of the post.
                <!-- NEED TO FINISH THIS.-->
            </conclusion>
        </answer>
        <sources>
            <citation style=""><!-- Optional sub-element --></citation> 
        </sources>    
    </blog_post>
    
    <docReview>
        <reviewer type="peer" xml:id="s24">Oliver Scott</reviewer>
        <report type="peer" resp="s24">
            <p>The post addresses the topic of path finding algorithms in mathematics, and by extension, computer science. 
                Its audience seems best fit to be those who have an understanding of some fundamental concepts
                from these disciplines, but are seeking a friendly introduction to path finding algorithms. (specifically
                Dijkstra's, Best-First, and A*)</p>
            <p> The structure and style of the post is exceptionally well thought through and does a very good job of 
                giving life to a potentially drab topic. Specifically the modular structure is effective 
                at building an inexperienced reader's knowledge, while the anthropomorphizing of the different algorithms allows
                their 'personalities' to give insight into how they might be used in separate circumstances.</p>
            <p>
                The current flow of the article is in a good place (as touched on above), however I think the arc could be 
                further developed to emphasize that A* is the focal point of the document. It feels as though
                it is being discussed as an equal to the other two approaches, and if it weren't for textual clues such as 
                'bro #1' and 'bro #2' when referring to the other two algorithms, its differentiation in importance in the document 
                is not immediately obvious. I think this could
                be improved in two ways. At present, the exposition of the document doesn't hint that A* is of greater focus
                than the other two algorithms -- other than it chronologically following the other two. Providing some explicit
                discussion of the 'roadmap' might allow for the reader to better understand why we are building to A*. Secondly,
                the underlying xml structure could be reworked to drive this home if Dijkstra's and BF were included in the 'background'
                section rather than in the 'answer' section.
            </p>
            <p>
                Overall it appears that the nuts and bolts of the genre are being properly adhered to, and stylistically I 
                imagine the cartoons will add the glue to help make accessible the details behind the topics. Given the primitive
                state of the document, it is difficult in a few passages to be sure if some confusion I experienced was due
                to sections that have yet to be proofread, or if better explanations should be developed. 
                I highlighted a few areas with notes that could benefit if the latter is the case.
                Lastly, I noticed you aren't using the 'important_idea' tag. It doesn't seem to take away from
                the work, however you might find it useful for areas in which you are driving home the differences between 
                various path-finding implementations. 
            </p>
        </report>
        
        <reviewer type="instructor" xml:id="kgs"/>
        <report type="instructor" resp="#kgs">
            <p>Comments on assignment will appear here.</p>
            
        </report>
    </docReview>
</DOC>
